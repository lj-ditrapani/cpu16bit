---------|---------|---------|---------|---------|---------|---------|--
http://jsfiddle.net/bL2eszp8/6/

16 x 2 x 16-bit colors
(16 pairs of 16-bit colors)
4 bit color pair index
8x8 pixel tiles
256 tile index
60 x 40 chars/tiles
480 x 320 pixel screen
video RAM
4,480 Words (< 9KB)
 +256 sprite attribute data for 128 sprites
 +300 (flip x, y grid cell tile)
5,036 Words (< 10,072B)

0 HLT
1 LBY    RD[07-00] <- immd8
2 HBY    RD[15-08] <- immd8
3 LOD    RD <- M[R1]
4 STR    M[R1] <- R2
5 ADD    RD <- RS1 + RS2
6 SUB    RD <- RS1 - RS2
7 ADI    RD <- RS1 + immd4
8 SBI    RD <- RS1 - immd4
9 AND    RD <- RS1 and RS2
A ORR    RD <- RS1 or RS2
B XOR    RD <- RS1 xor RS2
C NOT    RD <- ! R1
D SHF    RD <- RS1 shifted by immd4
E BRN    PC <- R2 if R1 matches NZPCV
F SPC    RD <- PC + 2

SHF  Shift, zero fill
Carry contains bit of last bit shifted out
immd4
DAAA
D is direction:  0 left, 1 right
AAA is (amount - 1)
0-7  ->  1-8
Assembly:
SHF R3 L 2 RA ->  $D31A
SHF R7 R 7 R0 ->  $D7E0

BRN M---
M is mode
0NZP    0 is value mode (negative zero positive)
10VC    1 is flag mode (overflow carry)
0111    unconditional jump
0000    no op

16 X 16-bit registers
Have seperate PC so we can do more in
parallel

64 KWords = 128 KB = 1 M-bit
20 MHz
10 Million instructions per second

Triple ported register file
(2 reads, 1 write per clock)
CPLD like Control
13 function ALU (4 control bits)


        Mm Reg  01 02 03
0 HLT    - --    0  0  0
1 LBY    - -W   UC UC RD
2 HBY    - -W   UC UC RD
3 LOD    R RW   RA  0 RD
4 STR    W R-   RA R2  0
5 ADD    - RW   R1 R2 RD
6 SUB    - RW   R1 R2 RD
7 ADI    - RW   R1 UC RD
8 SBI    - RW   R1 UC RD
9 AND    - RW   R1 R2 RD
A ORR    - RW   R1 R2 RD
B XOR    - RW   R1 R2 RD
C NOT    - RW   R1  0 RD
D SHF    - RW   R1 SC RD
E BRN    - RP   RV RP cond
F SPC    - RW    0  0 RD


Nibble 00:  op code
Nibble 01:  0, high nibble of 8-bit const, Memory address register,
            ALU input 1 register
Nibble 02:  0, low nibble of 8-bit const, data in register to STR DI,
            ALU input 2 register, unsigned const, signed const,
            PC address register
Nibble 03:  0, cond, destination register to WRITE to


0 HLT    Halt
1 LBY    Low byte
2 HBY    High byte
3 LOD    Load
4 STR    Store
5 ADD    
6 SUB    
7 ADI    Add 4-bit immediate
8 SBI    Subtract 4-bit immediate
9 AND    
A ORR    
B XOR    
C NOT    
D SHF    Shift
E BRN    Branch
F SPC    Save PC


Reg (1 clock)
Fetch instruction (memory read)       1 clock
Decode & Reg read & ALU & Reg write

STR (2 clocks)
Fetch instruction (memory read)       1 clock
Decode & Reg read
Memory write                          1 clock

LDR (2 clocks)
Fetch instruction (memory read)       1 clock
Decode & Reg read
Memory read & reg write               1 clock


Video Ram
32 16bit colors   32    Words
Single tile        8    Words   8 X 8 tile times 2 bits
                                (16 bits per word)
Tile index      2048    Words   256 tiles X 8 words
Each tile cell     1    Word    8 bit tile select +
        4 bit foreground color pair + 4 bit background color pair
Number of cells 2400    60 X 40
Total           4480    Words


I/O
10 Million instructions per second
 1 Million instructions per frame
   100 K instructions for I/O per frame
    10 K I/O operations per frame
       4,480 video output
       500 sound (20 changes of 20 registers)
       5K Network/HDD access (1K each read, 1K each write?)
       10 operation for keyboard input (10 key down, 10 key up)
                1 byte per action: first bit up or down,
                                   next seven = key code
                Saves up to 20 actions, anymore are dumped


Video hardware
--------------
Instead of doing copy over to video RAM, could use double buffer
So just swap buffers instead of doing copy; instantaneous!
Could do the same for all I/O.

First 90 ms of frame:  CPU controls RAM lines
Next 10 ms of frame:  CPU sleeps
    video chip controls RAM Address and data out lines
Video copies video RAM into local video ram (4,480 words)
Control returned to CPU
Video ram draws info to screen in continuous loop for next 90 ms

Video loop 1 (7 operations)
------------
1) Use row/col counters to load tile cell
2) Use tile slot color pair IDs to load 4 colors from color pairs
3) Use row/col counters and tile ID to load tile row
4) increment row/col counters as necessary
5) Switch buffers and goto 1)

Video loop 2 (8 operations)
------------
1) Draw 8 pixel row to screen (16-bit row)
2) Switch buffers Goto 1)

153 k cycles to complete
160 k * 6 = 960 k cycles
1.8 million cycles available


Words
   10 Keyboard input (20 actions per frame/200 actions per second)
4,480 Video out
  510 Sound out
2,048 Network I/O (1K read, 1K write)
2,048 HDD or SD card I/O (1K read, 1K write)
  256 Sprite attribute data

Sprites
128 sprites
2 words per sprite
256 words
Sprite data
position    color pairs    Mirrors    Tile  |  Total
x    y      1    2         x   y            |
6    6      4    4         1   1      8     |  30
30 bits < 2 words
